"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S3BucketProvider = void 0;
const aws_error_handler_1 = require("../helper/aws-error-handler");
const aws_provider_1 = require("../helper/aws-provider");
const _ = require("lodash");
class S3BucketProvider extends aws_provider_1.AwsProvider {
    collect(context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.listAllBuckets(context);
        });
    }
    listAllBuckets(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            const serviceName = 'S3';
            const regions = _.has(context, 'inputs.regions') ? context.inputs.regions : this.getRegions(serviceName);
            try {
                for (const region of regions) {
                    const s3 = this.getClient(serviceName, region);
                    const s3BucketsData = yield s3.listBuckets().promise();
                    if (s3BucketsData && s3BucketsData.Buckets) {
                        for (const bucket of s3BucketsData.Buckets) {
                            if (bucket.Name) {
                                const versioning = yield s3
                                    .getBucketVersioning({ Bucket: bucket.Name })
                                    .promise();
                                const encryption = yield s3
                                    .getBucketEncryption({ Bucket: bucket.Name })
                                    .promise();
                                const policyStatus = yield s3
                                    .getBucketPolicyStatus({ Bucket: bucket.Name })
                                    .promise();
                                result.push({
                                    name: bucket.Name,
                                    type: S3BucketProvider.RESOURCE_TYPE,
                                    meta: {
                                        region: region,
                                    },
                                    properties: Object.assign(Object.assign(Object.assign({}, versioning), encryption), policyStatus),
                                });
                            }
                        }
                    }
                }
            }
            catch (error) {
                aws_error_handler_1.handle(error);
            }
            return result;
        });
    }
}
exports.S3BucketProvider = S3BucketProvider;
S3BucketProvider.RESOURCE_TYPE = 'aws::s3::bucket';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiczMtYnVja2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2F3cy9yZXNvdXJjZXMvczMtYnVja2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLG1FQUFxRDtBQUVyRCx5REFBcUQ7QUFFckQsNEJBQTZCO0FBRTdCLE1BQWEsZ0JBQWlCLFNBQVEsMEJBQVc7SUFHbEMsT0FBTyxDQUFDLE9BQStCOztZQUNsRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEMsQ0FBQztLQUFBO0lBRWEsY0FBYyxDQUFDLE9BQStCOztZQUMxRCxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUM7WUFDOUIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDO1lBQ3pCLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBRXpHLElBQUk7Z0JBQ0YsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7b0JBQzVCLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBVyxDQUFDO29CQUN6RCxNQUFNLGFBQWEsR0FBNkIsTUFBTSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2pGLElBQUksYUFBYSxJQUFJLGFBQWEsQ0FBQyxPQUFPLEVBQUU7d0JBQzFDLEtBQUssTUFBTSxNQUFNLElBQUksYUFBYSxDQUFDLE9BQU8sRUFBRTs0QkFDMUMsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO2dDQUNmLE1BQU0sVUFBVSxHQUFxQyxNQUFNLEVBQUU7cUNBQzFELG1CQUFtQixDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztxQ0FDNUMsT0FBTyxFQUFFLENBQUM7Z0NBQ2IsTUFBTSxVQUFVLEdBQXFDLE1BQU0sRUFBRTtxQ0FDMUQsbUJBQW1CLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO3FDQUM1QyxPQUFPLEVBQUUsQ0FBQztnQ0FDYixNQUFNLFlBQVksR0FBdUMsTUFBTSxFQUFFO3FDQUM5RCxxQkFBcUIsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7cUNBQzlDLE9BQU8sRUFBRSxDQUFDO2dDQUNiLE1BQU0sQ0FBQyxJQUFJLENBQUM7b0NBQ1YsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJO29DQUNqQixJQUFJLEVBQUUsZ0JBQWdCLENBQUMsYUFBYTtvQ0FDcEMsSUFBSSxFQUFFO3dDQUNKLE1BQU0sRUFBRSxNQUFNO3FDQUNmO29DQUNELFVBQVUsZ0RBQ0wsVUFBVSxHQUNWLFVBQVUsR0FDVixZQUFZLENBQ2hCO2lDQUNGLENBQUMsQ0FBQzs2QkFDSjt5QkFDRjtxQkFDRjtpQkFDRjthQUNGO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ2QsMEJBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNmO1lBQ0QsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztLQUFBOztBQWhESCw0Q0FpREM7QUFoRHdCLDhCQUFhLEdBQUcsaUJBQWlCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYW5kbGUgfSBmcm9tICcuLi9oZWxwZXIvYXdzLWVycm9yLWhhbmRsZXInO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgQXdzUHJvdmlkZXIgfSBmcm9tICcuLi9oZWxwZXIvYXdzLXByb3ZpZGVyJztcbmltcG9ydCB7IFJlc291cmNlIH0gZnJvbSAnQGRlZXBsaW50L2RlZXBzY2FubmVyLWJhc2UnO1xuaW1wb3J0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcblxuZXhwb3J0IGNsYXNzIFMzQnVja2V0UHJvdmlkZXIgZXh0ZW5kcyBBd3NQcm92aWRlciB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkVTT1VSQ0VfVFlQRSA9ICdhd3M6OnMzOjpidWNrZXQnO1xuXG4gIHB1YmxpYyBhc3luYyBjb2xsZWN0KGNvbnRleHQ6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBQcm9taXNlPFJlc291cmNlW10+IHtcbiAgICByZXR1cm4gdGhpcy5saXN0QWxsQnVja2V0cyhjb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbGlzdEFsbEJ1Y2tldHMoY29udGV4dDogeyBba2V5OiBzdHJpbmddOiBhbnkgfSk6IFByb21pc2U8UmVzb3VyY2VbXT4ge1xuICAgIGNvbnN0IHJlc3VsdDogUmVzb3VyY2VbXSA9IFtdO1xuICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gJ1MzJztcbiAgICBjb25zdCByZWdpb25zID0gXy5oYXMoY29udGV4dCwgJ2lucHV0cy5yZWdpb25zJykgPyBjb250ZXh0LmlucHV0cy5yZWdpb25zIDogdGhpcy5nZXRSZWdpb25zKHNlcnZpY2VOYW1lKTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiByZWdpb25zKSB7XG4gICAgICAgIGNvbnN0IHMzID0gdGhpcy5nZXRDbGllbnQoc2VydmljZU5hbWUsIHJlZ2lvbikgYXMgQVdTLlMzO1xuICAgICAgICBjb25zdCBzM0J1Y2tldHNEYXRhOiBBV1MuUzMuTGlzdEJ1Y2tldHNPdXRwdXQgPSBhd2FpdCBzMy5saXN0QnVja2V0cygpLnByb21pc2UoKTtcbiAgICAgICAgaWYgKHMzQnVja2V0c0RhdGEgJiYgczNCdWNrZXRzRGF0YS5CdWNrZXRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBidWNrZXQgb2YgczNCdWNrZXRzRGF0YS5CdWNrZXRzKSB7XG4gICAgICAgICAgICBpZiAoYnVja2V0Lk5hbWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbmluZzogQVdTLlMzLkdldEJ1Y2tldFZlcnNpb25pbmdPdXRwdXQgPSBhd2FpdCBzM1xuICAgICAgICAgICAgICAgIC5nZXRCdWNrZXRWZXJzaW9uaW5nKHsgQnVja2V0OiBidWNrZXQuTmFtZSB9KVxuICAgICAgICAgICAgICAgIC5wcm9taXNlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRpb246IEFXUy5TMy5HZXRCdWNrZXRFbmNyeXB0aW9uT3V0cHV0ID0gYXdhaXQgczNcbiAgICAgICAgICAgICAgICAuZ2V0QnVja2V0RW5jcnlwdGlvbih7IEJ1Y2tldDogYnVja2V0Lk5hbWUgfSlcbiAgICAgICAgICAgICAgICAucHJvbWlzZSgpO1xuICAgICAgICAgICAgICBjb25zdCBwb2xpY3lTdGF0dXM6IEFXUy5TMy5HZXRCdWNrZXRQb2xpY3lTdGF0dXNPdXRwdXQgPSBhd2FpdCBzM1xuICAgICAgICAgICAgICAgIC5nZXRCdWNrZXRQb2xpY3lTdGF0dXMoeyBCdWNrZXQ6IGJ1Y2tldC5OYW1lIH0pXG4gICAgICAgICAgICAgICAgLnByb21pc2UoKTtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IGJ1Y2tldC5OYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IFMzQnVja2V0UHJvdmlkZXIuUkVTT1VSQ0VfVFlQRSxcbiAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICByZWdpb246IHJlZ2lvbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnZlcnNpb25pbmcsXG4gICAgICAgICAgICAgICAgICAuLi5lbmNyeXB0aW9uLFxuICAgICAgICAgICAgICAgICAgLi4ucG9saWN5U3RhdHVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGUoZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=