"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Module = void 0;
const path = require("path");
const policy_1 = require("../policy/policy");
const constant_1 = require("../constant");
const yaml_reader_1 = require("../shared/yaml-reader");
const input_processing_1 = require("../shared/input-processing");
const path_1 = require("../shared/path");
const validate_1 = require("../policy/validate");
const fs = require("fs");
class Module {
    constructor(meta, policies) {
        this.meta = meta;
        this.policies = policies;
    }
    static async build(moduleConfig, moduleName) {
        // 1. Get and validate the module path
        const modulePath = path_1.resolveModulePath(moduleName, moduleConfig.uses);
        if (moduleName !== constant_1.ROOT_MODULE_NAME && !fs.existsSync(modulePath + path.sep + constant_1.DEFAULT_POLICY_SPEC_FILE_NAME)) {
            throw new Error(`Can not find the module: ${moduleName} with path: ${modulePath}`);
        }
        if (moduleName === constant_1.ROOT_MODULE_NAME && !fs.existsSync(modulePath + path.sep + constant_1.DEFAULT_DEEPLINT_CONFIG_FILE_NAME)) {
            throw new Error(`Can not find the config: ${constant_1.DEFAULT_DEEPLINT_CONFIG_FILE_NAME}`);
        }
        // 2. Load and validate module spec
        const moduleSpec = moduleName === constant_1.ROOT_MODULE_NAME ?
            yaml_reader_1.default.load(modulePath + path.sep + constant_1.DEFAULT_DEEPLINT_CONFIG_FILE_NAME) : yaml_reader_1.default.load(modulePath + path.sep + constant_1.DEFAULT_MODULE_SPEC_FILE_NAME);
        if (!validate_1.validate('ModuleSpec', moduleSpec)) {
            throw new Error(`Module spec ${JSON.stringify(moduleSpec)} does not follow the required format`);
        }
        // 3. Process and apply inputs
        const inputs = input_processing_1.processInputs(moduleName, moduleConfig.with, moduleSpec.inputs);
        const processedModuleSpec = input_processing_1.applyInputs(moduleSpec, inputs);
        // 4. Build policies
        const policies = new Map();
        await Object.keys(processedModuleSpec.policies).map(async (key) => {
            const policy = await policy_1.Policy.build(processedModuleSpec.policies[key], key, moduleName);
            policies.set(key, policy);
        });
        return new Module({
            moduleName: moduleName,
            moduleConfig: moduleConfig,
            modulePath: modulePath,
            moduleSpec: moduleSpec,
        }, policies);
    }
    getPoliciesMeta() {
        const res = {};
        Object.keys(this.meta.moduleSpec.policies).map(async (policyKey) => {
            const policy = this.policies.get(policyKey);
            if (policy === undefined) {
                throw (new Error(`Can not locate policy: ${policyKey}`));
            }
            res[policyKey] = policy.meta;
        });
        return res;
    }
    async snap() {
        const res = {};
        await Promise.all(Object.keys(this.meta.moduleSpec.policies).map(async (policyKey) => {
            const policy = this.policies.get(policyKey);
            if (policy === undefined) {
                throw (new Error(`Can not locate policy: ${policyKey}`));
            }
            res[policyKey] = await policy.snap();
        }));
        return res;
    }
    async check(snapshots) {
        const res = {};
        await Promise.all(Object.keys(snapshots).map(async (policyKey) => {
            const policy = this.policies.get(policyKey);
            if (policy === undefined) {
                throw (new Error(`Can not locate policy: ${policyKey}`));
            }
            res[policyKey] = await policy.check(snapshots[policyKey]);
        }));
        return res;
    }
    async fix(checkingResults) {
        const res = {};
        await Promise.all(Object.keys(checkingResults).map(async (policyKey) => {
            const policy = this.policies.get(policyKey);
            if (policy === undefined) {
                throw (new Error(`Can not locate policy: ${policyKey}`));
            }
            res[policyKey] = await policy.fix(checkingResults[policyKey]);
        }));
        return res;
    }
}
exports.Module = Module;
