"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Policy = void 0;
const path = require("path");
const yaml_reader_1 = require("../shared/yaml-reader");
const invoker_1 = require("./invoker");
const _ = require("lodash");
const constant_1 = require("../constant");
const context_1 = require("./context");
const validate_1 = require("./validate");
const input_processing_1 = require("../shared/input-processing");
const path_1 = require("../shared/path");
const fs = require("fs");
class Policy {
    constructor(meta, processedInputs) {
        this.meta = meta;
        this.processedInputs = processedInputs;
    }
    get rules() {
        return this.meta.policySpec.rules;
    }
    get name() {
        return this.meta.policyName;
    }
    get path() {
        return this.meta.policyPath;
    }
    get actions() {
        return this.meta.policySpec.actions;
    }
    get scanners() {
        return this.meta.policySpec.scanners;
    }
    get inputs() {
        return this.processedInputs;
    }
    static async build(policyConfig, policyName, moduleName) {
        const policyPath = path_1.resolvePolicyPath(moduleName, policyName, policyConfig.uses);
        if (!fs.existsSync(policyPath + path.sep + constant_1.DEFAULT_POLICY_SPEC_FILE_NAME)) {
            throw new Error(`Can not find the policy: ${policyName} in module: ${moduleName} with path: ${policyPath}`);
        }
        const policySpec = yaml_reader_1.default.load(policyPath + path.sep + constant_1.DEFAULT_POLICY_SPEC_FILE_NAME);
        if (!validate_1.validate('PolicySpec', policySpec)) {
            throw new Error(`Policy spec ${JSON.stringify(policySpec)} does not follow the required format`);
        }
        const inputs = input_processing_1.processInputs(policyName, policyConfig.with, policySpec.inputs);
        return new Policy({
            policyName: policyName,
            policyPath: policyPath,
            policySpec: policySpec,
            policyConfig: policyConfig,
        }, inputs);
    }
    async snap() {
        const resources = {};
        await Promise.all(Object.keys(this.meta.policySpec.scanners).map(async (scannerKey) => {
            const functionPath = path.resolve(this.meta.policyPath, this.meta.policySpec.scanners[scannerKey].uses);
            const resources_temp = await invoker_1.Invoker.run(new context_1.Context(this.meta, this.processedInputs), functionPath, this.meta.policySpec.scanners[scannerKey].main);
            resources_temp.forEach(resource => {
                if (!validate_1.validate('Resource', resource)) {
                    throw new Error(`Resource ${JSON.stringify(resource)} does not follow the required format`);
                }
            });
            resources[scannerKey] = resources_temp;
        }));
        return {
            timestamp: new Date(),
            resources: resources,
        };
    }
    async check(snapshot) {
        const checkingResults = {};
        const context = new context_1.CheckContext(this.meta, this.processedInputs, snapshot);
        await Promise.all(Object.keys(this.rules).map(async (ruleKey) => {
            const functionPath = path.resolve(this.path, this.rules[ruleKey].uses);
            const checkingResult = await invoker_1.Invoker.run(context, functionPath, this.rules[ruleKey].main);
            if (!validate_1.validate('CheckingResult', checkingResult)) {
                throw new Error(`Checking Result ${JSON.stringify(checkingResult)} does not follow the required format`);
            }
            checkingResults[ruleKey] = checkingResult;
        }));
        return checkingResults;
    }
    async fix(checkingResults) {
        const fixingResults = {};
        await Promise.all(Object.keys(checkingResults).map(async (key) => {
            const checkingResult = checkingResults[key];
            if (!checkingResult.passed && checkingResult.problem && checkingResult.problem.fix !== undefined && this.actions) {
                if (_.has(this.actions, checkingResult.problem.fix)) {
                    const functionPath = path.resolve(this.path, this.actions[checkingResult.problem.fix].uses);
                    fixingResults[key] = await invoker_1.Invoker.run(new context_1.Context(this.meta, this.inputs), functionPath, this.actions[checkingResult.problem.fix].main);
                }
                else {
                    throw new Error(`Invalid fix action: ${checkingResult.problem.fix}`);
                }
            }
        }));
        return fixingResults;
    }
}
exports.Policy = Policy;
